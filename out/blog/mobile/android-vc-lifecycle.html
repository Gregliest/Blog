<!DOCTYPE html><html lang="en" class="scroll-smooth"><head><meta charSet="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><title>iOS &gt; Android: View Life Cycle</title><meta name="robots" content="follow, index"/><meta name="description" content="A comparison of the view and controller life cycle hooks in iOS and Android."/><meta property="og:url" content="https://gregliest.github.io/blog/mobile/android-vc-lifecycle"/><meta property="og:type" content="article"/><meta property="og:site_name" content="Blog"/><meta property="og:description" content="A comparison of the view and controller life cycle hooks in iOS and Android."/><meta property="og:title" content="iOS &gt; Android: View Life Cycle"/><meta property="og:image" content="https://gregliest.github.io/static/images/twitter-card.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:title" content="iOS &gt; Android: View Life Cycle"/><meta name="twitter:description" content="A comparison of the view and controller life cycle hooks in iOS and Android."/><meta name="twitter:image" content="https://gregliest.github.io/static/images/twitter-card.png"/><link rel="canonical" href="https://gregliest.github.io/blog/mobile/android-vc-lifecycle"/><meta property="article:published_time" content="2014-11-23T15:31:09.000Z"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gregliest.github.io/blog/mobile/android-vc-lifecycle"
  },
  "headline": "iOS > Android: View Life Cycle",
  "image": [
    {
      "@type": "ImageObject",
      "url": "https://gregliest.github.io/static/images/twitter-card.png"
    }
  ],
  "datePublished": "2014-11-23T15:31:09.000Z",
  "dateModified": "2014-11-23T15:31:09.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Gregory Lee"
    }
  ],
  "publisher": {
    "@type": "Organization",
    "name": "Gregory Lee",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gregliest.github.io/static/images/logo.png"
    }
  },
  "description": "A comparison of the view and controller life cycle hooks in iOS and Android."
}</script><meta name="next-head-count" content="19"/><link rel="apple-touch-icon" sizes="76x76" href="/static/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/static/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/static/favicons/favicon-16x16.png"/><link rel="manifest" href="/static/favicons/site.webmanifest"/><link rel="mask-icon" href="/static/favicons/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#000000"/><meta name="theme-color" content="#000000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><link rel="preload" href="/_next/static/css/4998f4c6a354514b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4998f4c6a354514b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-cf9c328f706f1fd5.js" defer=""></script><script src="/_next/static/chunks/framework-109a728694328ca8.js" defer=""></script><script src="/_next/static/chunks/main-05393c48e9316d33.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f9d2e67b91e759ce.js" defer=""></script><script src="/_next/static/chunks/675-14c3b3baa8506076.js" defer=""></script><script src="/_next/static/chunks/266-f485f5b68acdf582.js" defer=""></script><script src="/_next/static/chunks/486-47259eb0bf813a5f.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5B...slug%5D-d42440c49924bf1f.js" defer=""></script><script src="/_next/static/Uk5C59Zgl51sx5Hq37kK4/_buildManifest.js" defer=""></script><script src="/_next/static/Uk5C59Zgl51sx5Hq37kK4/_ssgManifest.js" defer=""></script></head><body class="bg-white text-black antialiased dark:bg-gray-900 dark:text-white"><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&false)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}else{c.add('light')}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'light'}catch(e){}}()</script><div class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="flex h-screen flex-col justify-between"><header class="flex items-center justify-between py-10"><div><a aria-label="" href="/"><div class="flex items-center justify-between"><div class="mr-3"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="344.564 330.278 111.737 91.218" width="53.87" height="43.61" role="img"><defs><linearGradient id="logo_svg__b" gradientUnits="userSpaceOnUse" x1="420.97" y1="331.28" x2="420.97" y2="418.5"><stop style="stop-color:#06b6d4;stop-opacity:1" offset="0%"></stop><stop style="stop-color:#67e8f9;stop-opacity:1" offset="100%"></stop></linearGradient><linearGradient id="logo_svg__d" gradientUnits="userSpaceOnUse" x1="377.89" y1="331.28" x2="377.89" y2="418.5"><stop style="stop-color:#06b6d4;stop-opacity:1" offset="0%"></stop><stop style="stop-color:#67e8f9;stop-opacity:1" offset="100%"></stop></linearGradient><path d="M453.3 331.28v28.57l-64.66 58.65v-30.08l64.66-57.14Z" id="logo_svg__a"></path><path d="M410.23 331.28v28.57l-64.67 58.65v-30.08l64.67-57.14Z" id="logo_svg__c"></path></defs><use xlink:href="#logo_svg__a" fill="url(#logo_svg__b)"></use><use xlink:href="#logo_svg__c" fill="url(#logo_svg__d)"></use></svg></div><div class="hidden h-6 text-2xl font-semibold sm:block"></div></div></a></div><div class="flex items-center text-base leading-5"><div class="hidden sm:block"><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/code">Code</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/whitewater">Whitewater</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/photography">Photography</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/ideas">Ideas</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/blog">Blog</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/tags">Tags</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/projects">Projects</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/about">About</a></div><button aria-label="Toggle Dark Mode" type="button" class="ml-1 mr-1 h-8 w-8 rounded p-1 sm:ml-4"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="text-gray-900 dark:text-gray-100"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg></button><div class="sm:hidden"><button type="button" class="ml-1 mr-1 h-8 w-8 rounded py-1" aria-label="Toggle Menu"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg></button><div class="fixed top-24 right-0 z-10 h-full w-full transform bg-gray-200 opacity-95 duration-300 ease-in-out dark:bg-gray-800 translate-x-full"><button type="button" aria-label="toggle modal" class="fixed h-full w-full cursor-auto focus:outline-none"></button><nav class="fixed mt-8 h-full"><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/code">Code</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/whitewater">Whitewater</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/photography">Photography</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/ideas">Ideas</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/blog">Blog</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/tags">Tags</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/projects">Projects</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" href="/about">About</a></div></nav></div></div></div></header><main class="mb-auto"><div class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="fixed right-8 bottom-8 hidden flex-col gap-3 md:hidden"><button aria-label="Scroll To Comment" type="button" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clip-rule="evenodd"></path></svg></button><button aria-label="Scroll To Top" type="button" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg></button></div><article><div class="xl:divide-y xl:divide-gray-200 xl:dark:divide-gray-700"><header class="pt-6 xl:pb-6"><div class="space-y-1 text-center"><dl class="space-y-10"><div><dt class="sr-only">Published on</dt><dd class="text-base font-medium leading-6 text-gray-500 dark:text-gray-400"><time dateTime="2014-11-23T15:31:09.000Z">Sunday, November 23, 2014</time></dd></div></dl><div><h1 class="text-3xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14">iOS &gt; Android: View Life Cycle</h1></div></div></header><div class="divide-y divide-gray-200 pb-8 dark:divide-gray-700 xl:grid xl:grid-cols-4 xl:gap-x-6 xl:divide-y-0" style="grid-template-rows:auto 1fr"><dl class="pt-6 pb-10 xl:border-b xl:border-gray-200 xl:pt-11 xl:dark:border-gray-700"><dt class="sr-only">Authors</dt><dd><ul class="flex justify-center space-x-8 sm:space-x-12 xl:block xl:space-x-0 xl:space-y-8"><li class="flex items-center space-x-2"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2738%27%20height=%2738%27/%3e"/></span><img alt="avatar" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="h-10 w-10 rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="avatar" src="/static/images/avatar.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="h-10 w-10 rounded-full" loading="lazy"/></noscript></span><dl class="whitespace-nowrap text-sm font-medium leading-5"><dt class="sr-only">Name</dt><dd class="text-gray-900 dark:text-gray-100">Gregory Lee</dd><dt class="sr-only">Twitter</dt><dd><a target="_blank" rel="noopener noreferrer" href="https://twitter.com/Twitter" class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400">@Twitter</a></dd></dl></li></ul></dd></dl><div class="divide-y divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0"><div class="prose max-w-none pt-10 pb-8 dark:prose-dark"><p>In this post, I’m going to compare the life cycle hooks in iOS and Android, and discuss at a high level why iOS’s system is superior to Android’s. In general, iOS provides hooks that match the life cycle of the view, which creates an easy and intuitive system, and successfully hides system level concerns from the developer. On the other hand, Android&#x27;s hooks follow the state of the controller, which conflates the life cycle of the view with the state of the controller, breaking the fundamental abstraction of MVC. This terrible design creates a confusing and quirky system, and exposes system level complexity to the developer.</p><h1 id="mvc-refresher"><a href="#mvc-refresher" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>MVC refresher</h1><p>To establish terminology, I&#x27;ll quickly discuss <a target="_blank" rel="noopener noreferrer" href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller</a>, the design paradigm favored by both platforms. MVC seeks to reduce the complexity of user interfaces by separating concerns into models, views, and controllers. Models hold the data. Views are the representation of the data on screen, and should contain minimal logic. Controllers manage the views and their life cycle, and coordinate with models and the rest of the app. Since controllers are in the middle of everything, they are usually significantly more complicated than views.</p><h1 id="the-view-life-cycle"><a href="#the-view-life-cycle" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>The View Life Cycle</h1><p>When a view is about to appear on screen, the app needs to perform the following tasks:</p><ol><li>Create the view and load into memory</li><li>Lay out and measure the elements of the view</li><li>Render the view on screen</li></ol><p>And when the view should leave the screen:</p><ol><li>Hide the view</li><li>Release memory</li></ol><p>These tasks represent the major stages in a view&#x27;s life cycle, and a developer might want to take action at some or all of these stages. For instance, a developer may wish to persist the state of the UI when a view is going off screen. To support these actions, each platform has provided a number of hooks in their controllers.</p><h1 id="the-life-cycle-hooks"><a href="#the-life-cycle-hooks" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>The Life Cycle Hooks</h1><p>Apple&#x27;s most common methods are:</p><ol><li>ViewDidLoad</li><li>ViewWillAppear</li><li>ViewDidAppear</li><li>ViewWillDisappear</li><li>ViewDidDisappear</li></ol><p>As you can see from names like &#x27;viewDid&#x27; and &#x27;viewWill,&#x27; the iOS hooks are focused on the state of the view. The hooks do not make any assertions about the state of the controller, or the larger state of the app. Apple has successfully separated the concerns of the view from the concerns of the rest of the app in their life cycle hooks.</p><p>This separation, along with aptly-named hooks, creates an intuitive system. For instance, it&#x27;s obvious that <code>viewWillAppear</code> will get called when the view is about to appear. It is also clear that <code>viewDidAppear</code> will get called after the view has been rendered on screen, and after any associated system level tasks have been completed. In general, I find the iOS hooks clearly named, and thoughtfully laid out. I will note that the developer is still responsible for learning what happens at a system level before each hook. For instance, views are not measure in <code>viewDidLoad</code>, so any requests for a dimension will return 0, which can be a source of frustration for new developers. But I find these details easy to look up.</p><p>Here are the equivalent Android docs.</p><div><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27662%27%20height=%27295%27/%3e"/></span><img alt="Android Lifecycle" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Android Lifecycle" src="/static/images/lifecycle/basic-lifecycle-android.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></div><p>In contrast to iOS, Android&#x27;s hooks get called when the <em>controller</em> is about to change state, not the view. The states, like &quot;paused&quot; and &quot;resumed,&quot; are controller states. In fact, Android&#x27;s hooks make no mention of the view at all, and as we will see, only have a peripheral connection to the life cycle of the view. This abstraction is incorrect and adds enormous complexity to Android&#x27;s system.</p><p>This incorrect abstraction is apparent in the names of Android&#x27;s hooks, which are confusing and ambiguous. For instance, what does it mean for a controller to be &quot;started,&quot; and how is that different than &quot;resumed?&quot; What is the distinction between &quot;paused&quot; and &quot;stopped?&quot; These state names do not convey the nuance and complexity that they encompass. Notice that the docs have parentheses explaining how these controller states match to the view life cycle, which is the more natural way to understand when these hooks will be called. Furthermore, by using the terminology &quot;onEvent,&quot; Android fails to communicate whether system level events tied to that event come before or after the hook. For instance, when a controller is paused, is the hook called immediately while the view is still on screen, or after the view has been partially occluded? This ambiguous naming increases learning time and adds cognitive overhead.</p><p>Here&#x27;s a quick comparison of the most common lifecycle methods on the two platforms, and where they fit into the life cycle of the view.</p><div><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27960%27%20height=%27540%27/%3e"/></span><img alt="View Appearing" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="View Appearing" src="/static/images/lifecycle/view-controller-appear.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></div><div><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27960%27%20height=%27540%27/%3e"/></span><img alt="View Disappearing" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="View Disappearing" src="/static/images/lifecycle/view-controller-disappear.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></div><p>Side by side, the difference between iOS&#x27;s view abstraction and Android&#x27;s controller abstraction becomes apparent. Apple has one hook at each stage, but Android sometimes has multiple hooks, or no hooks at all. In other words, Android&#x27;s controller abstraction doesn&#x27;t match what a developer needs to do, making the system difficult to understand, and making it difficult to figure out where code should go.</p><p>Furthermore, by abstracting on the controller events, Android has tightly coupled the view&#x27;s life cycle with the controller&#x27;s life cycle, breaking the fundamental abstraction of MVC. For instance, on screen rotation, Android envisioned a scenario where a developer would want to substitute different layouts for landscape and portrait modes. This is a noble goal, and I applaud the flexibility that it grants. However, due to the controller abstraction, in order to change the view, the <em>controller</em> also needs to change. In other words, to swap out the view and call all of the life cycle hooks again, the entire controller needs to be destroyed and recreated, along with all of its data and state. If the controller is not recreated properly, the resulting view could have bugs, lose data, or even crash, even though nothing in the controller has changed. Thus, by abstracting on the controller, Android has complected the view and the controller, which breaks the basic abstraction of MVC. It&#x27;s an absolutely terrible design. As if that&#x27;s not bad enough, saving and recreating a view can be heinously difficult, which I will cover in a separate blog post.</p><p>Rotation is not an isolated case; Android&#x27;s controller abstraction leaks controller concerns and system level complexity into the realm of the developer anywhere and everywhere. Here&#x27;s a partial list of other life cycle quirks and gotchas that await the unwary Android developer.</p><ul><li>Backgrounded apps brought to the foreground will often crash if state is not persisted properly.</li><li>The developer has to be aware that the system can destroy activities in the background.</li><li>onSaveInstanceState is not always called, such as when the user “intentionally” exits the app.</li><li>The developer has to manually cache the state of the controller.</li><li>Persisted controllers can have data split between a bundle and a permanent store.</li><li>There are often multiple ways that a hook can be called, and the developer needs to be aware of the differences in certain situations.</li><li>There are quirks with older versions of Android, notably that <code>onStop</code> is not guaranteed to be called in early versions of Android.</li><li>Google maps objects have their own separate hell of a life cycle.</li></ul><p>Some of these points represent major failures of design, while others &quot;merely&quot; add complexity. While discussing these issues is beyond the scope of this post, if there&#x27;s anything in particular you would like to read more about, drop me a comment and I&#x27;ll do my best to put together a post on that subject.</p><p>In contrast to Android, by tying hooks to the view, iOS has found the correct abstraction. The hooks only assert that the view did appear, or the view will disappear. There is no mention of, and really no room for, a concept of why these events might have happened. Thus, the view abstraction <strong>requires</strong> that much of the controller complexity be handled in the background. Complexity around whether a view should be cached, whether the system needs to reclaim memory from the controller, etc, CANNOT leak out into the realm of the developer. It&#x27;s a fantastic separation of concerns, enforced by design.</p><p>To sum up, when I learned iOS, I coded for months with only the barest appreciation for what was being handled for me behind the scenes. I had no idea what the system was doing to my views and controllers when the app was backgrounded, or when the phone was rotated. And I didn&#x27;t care, I put my code in the logical life cycle hook, and it just worked. On the other hand, by requiring the developer to be aware of the controller&#x27;s state, Android has introduced a massive amount of incidental complexity. Eight months into the development of my first Android app, I was still encountering issues, edge cases, and crashes pertaining to lifecycle. I was still referring to documentation, and discovering new, important details about how the system worked. Overall, Android&#x27;s handling of life cycle feels poorly designed, and poorly executed. In fairness to the framework engineers, Java imposes limitations, and I&#x27;m sure there are many other constraints that I&#x27;m not aware of that pushed the design in this direction. But, with iOS as an example, I would like to see reductions in the complexity of view and controller life cycle in future versions of Android.</p></div><div class="pt-6 pb-6 text-sm text-gray-700 dark:text-gray-300"><a target="_blank" rel="nofollow" href="https://mobile.twitter.com/search?q=https%3A%2F%2Fgregliest.github.io%2Fblog%2Fmobile%2Fandroid-vc-lifecycle">Discuss on Twitter</a> • <a target="_blank" rel="noopener noreferrer" href="https://github.com/gregliest/Blog/blob/master/data/blog/mobile/android-vc-lifecycle">View on GitHub</a></div><div id="comment"></div></div><footer><div class="divide-gray-200 text-sm font-medium leading-5 dark:divide-gray-700 xl:col-start-1 xl:row-start-2 xl:divide-y"><div class="py-4 xl:py-8"><h2 class="text-xs uppercase tracking-wide text-gray-500 dark:text-gray-400">Tags</h2><div class="flex flex-wrap"><a class="mr-3 text-sm font-medium uppercase text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/tags/code">code</a><a class="mr-3 text-sm font-medium uppercase text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/tags/android">android</a><a class="mr-3 text-sm font-medium uppercase text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/tags/ios">iOS</a><a class="mr-3 text-sm font-medium uppercase text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/tags/mobile">mobile</a></div></div><div class="flex justify-between py-4 xl:block xl:space-y-8 xl:py-8"><div><h2 class="text-xs uppercase tracking-wide text-gray-500 dark:text-gray-400">Previous Article</h2><div class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400"><a href="/blog/mobile/android-layouts-3">Layouts Part III: The Beauty of Layout Weight and Conclusion</a></div></div><div><h2 class="text-xs uppercase tracking-wide text-gray-500 dark:text-gray-400">Next Article</h2><div class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400"><a href="/blog/photography/el-capitan-climbers">El Capitan Climbers</a></div></div></div></div><div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/blog">← Back to the blog</a></div></footer></div></div></article></div></main><footer><div class="mt-16 flex flex-col items-center"><div class="mb-3 flex space-x-4"><a class="text-sm text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="mailto:blog@gregliest.com"><span class="sr-only">mail</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" role="img" class="fill-current text-gray-700 hover:text-blue-500 dark:text-gray-200 dark:hover:text-blue-400 h-6 w-6"><path d="M2.003 5.884 10 9.882l7.997-3.998A2 2 0 0 0 16 4H4a2 2 0 0 0-1.997 1.884z"></path><path d="m18 8.118-8 4-8-4V14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8.118z"></path></svg></a><a class="text-sm text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://github.com/gregliest"><span class="sr-only">github</span><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img" class="fill-current text-gray-700 hover:text-blue-500 dark:text-gray-200 dark:hover:text-blue-400 h-6 w-6"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><a class="text-sm text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com"><span class="sr-only">linkedin</span><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img" class="fill-current text-gray-700 hover:text-blue-500 dark:text-gray-200 dark:hover:text-blue-400 h-6 w-6"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 0 1-2.063-2.065 2.064 2.064 0 1 1 2.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg></a></div><div class="mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400"><div>Gregory Lee</div><div> • </div><div>© 2022</div><div> • </div><a href="/">Blog</a></div><div class="mb-8 text-sm text-gray-500 dark:text-gray-400"><a target="_blank" rel="noopener noreferrer" href="https://github.com/timlrx/tailwind-nextjs-starter-blog">Tailwind Nextjs Theme</a></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"iOS \u003e Android: View Life Cycle","date":"2014-11-23T15:31:09.000Z","summary":"A comparison of the view and controller life cycle hooks in iOS and Android.","tags":["code","android","iOS","mobile"],"thumbnail":"/static/images/lifecycle/basic-lifecycle-android.png","body":{"raw":"\nIn this post, I’m going to compare the life cycle hooks in iOS and Android, and discuss at a high level why iOS’s system is superior to Android’s. In general, iOS provides hooks that match the life cycle of the view, which creates an easy and intuitive system, and successfully hides system level concerns from the developer. On the other hand, Android's hooks follow the state of the controller, which conflates the life cycle of the view with the state of the controller, breaking the fundamental abstraction of MVC. This terrible design creates a confusing and quirky system, and exposes system level complexity to the developer.\n\n# MVC refresher\n\nTo establish terminology, I'll quickly discuss [Model-View-Controller](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller), the design paradigm favored by both platforms. MVC seeks to reduce the complexity of user interfaces by separating concerns into models, views, and controllers. Models hold the data. Views are the representation of the data on screen, and should contain minimal logic. Controllers manage the views and their life cycle, and coordinate with models and the rest of the app. Since controllers are in the middle of everything, they are usually significantly more complicated than views.\n\n# The View Life Cycle\n\nWhen a view is about to appear on screen, the app needs to perform the following tasks:\n\n1. Create the view and load into memory\n2. Lay out and measure the elements of the view\n3. Render the view on screen\n\nAnd when the view should leave the screen:\n\n1. Hide the view\n2. Release memory\n\nThese tasks represent the major stages in a view's life cycle, and a developer might want to take action at some or all of these stages. For instance, a developer may wish to persist the state of the UI when a view is going off screen. To support these actions, each platform has provided a number of hooks in their controllers.\n\n# The Life Cycle Hooks\n\nApple's most common methods are:\n\n1. ViewDidLoad\n2. ViewWillAppear\n3. ViewDidAppear\n4. ViewWillDisappear\n5. ViewDidDisappear\n\nAs you can see from names like 'viewDid' and 'viewWill,' the iOS hooks are focused on the state of the view. The hooks do not make any assertions about the state of the controller, or the larger state of the app. Apple has successfully separated the concerns of the view from the concerns of the rest of the app in their life cycle hooks.\n\nThis separation, along with aptly-named hooks, creates an intuitive system. For instance, it's obvious that `viewWillAppear` will get called when the view is about to appear. It is also clear that `viewDidAppear` will get called after the view has been rendered on screen, and after any associated system level tasks have been completed. In general, I find the iOS hooks clearly named, and thoughtfully laid out. I will note that the developer is still responsible for learning what happens at a system level before each hook. For instance, views are not measure in `viewDidLoad`, so any requests for a dimension will return 0, which can be a source of frustration for new developers. But I find these details easy to look up.\n\nHere are the equivalent Android docs.\n\n![Android Lifecycle](/static/images/lifecycle/basic-lifecycle-android.png)\n\nIn contrast to iOS, Android's hooks get called when the _controller_ is about to change state, not the view. The states, like \"paused\" and \"resumed,\" are controller states. In fact, Android's hooks make no mention of the view at all, and as we will see, only have a peripheral connection to the life cycle of the view. This abstraction is incorrect and adds enormous complexity to Android's system.\n\nThis incorrect abstraction is apparent in the names of Android's hooks, which are confusing and ambiguous. For instance, what does it mean for a controller to be \"started,\" and how is that different than \"resumed?\" What is the distinction between \"paused\" and \"stopped?\" These state names do not convey the nuance and complexity that they encompass. Notice that the docs have parentheses explaining how these controller states match to the view life cycle, which is the more natural way to understand when these hooks will be called. Furthermore, by using the terminology \"onEvent,\" Android fails to communicate whether system level events tied to that event come before or after the hook. For instance, when a controller is paused, is the hook called immediately while the view is still on screen, or after the view has been partially occluded? This ambiguous naming increases learning time and adds cognitive overhead.\n\nHere's a quick comparison of the most common lifecycle methods on the two platforms, and where they fit into the life cycle of the view.\n\n![View Appearing](/static/images/lifecycle/view-controller-appear.png)\n\n![View Disappearing](/static/images/lifecycle/view-controller-disappear.png)\n\nSide by side, the difference between iOS's view abstraction and Android's controller abstraction becomes apparent. Apple has one hook at each stage, but Android sometimes has multiple hooks, or no hooks at all. In other words, Android's controller abstraction doesn't match what a developer needs to do, making the system difficult to understand, and making it difficult to figure out where code should go.\n\nFurthermore, by abstracting on the controller events, Android has tightly coupled the view's life cycle with the controller's life cycle, breaking the fundamental abstraction of MVC. For instance, on screen rotation, Android envisioned a scenario where a developer would want to substitute different layouts for landscape and portrait modes. This is a noble goal, and I applaud the flexibility that it grants. However, due to the controller abstraction, in order to change the view, the _controller_ also needs to change. In other words, to swap out the view and call all of the life cycle hooks again, the entire controller needs to be destroyed and recreated, along with all of its data and state. If the controller is not recreated properly, the resulting view could have bugs, lose data, or even crash, even though nothing in the controller has changed. Thus, by abstracting on the controller, Android has complected the view and the controller, which breaks the basic abstraction of MVC. It's an absolutely terrible design. As if that's not bad enough, saving and recreating a view can be heinously difficult, which I will cover in a separate blog post.\n\nRotation is not an isolated case; Android's controller abstraction leaks controller concerns and system level complexity into the realm of the developer anywhere and everywhere. Here's a partial list of other life cycle quirks and gotchas that await the unwary Android developer.\n\n- Backgrounded apps brought to the foreground will often crash if state is not persisted properly.\n- The developer has to be aware that the system can destroy activities in the background.\n- onSaveInstanceState is not always called, such as when the user “intentionally” exits the app.\n- The developer has to manually cache the state of the controller.\n- Persisted controllers can have data split between a bundle and a permanent store.\n- There are often multiple ways that a hook can be called, and the developer needs to be aware of the differences in certain situations.\n- There are quirks with older versions of Android, notably that `onStop` is not guaranteed to be called in early versions of Android.\n- Google maps objects have their own separate hell of a life cycle.\n\nSome of these points represent major failures of design, while others \"merely\" add complexity. While discussing these issues is beyond the scope of this post, if there's anything in particular you would like to read more about, drop me a comment and I'll do my best to put together a post on that subject.\n\nIn contrast to Android, by tying hooks to the view, iOS has found the correct abstraction. The hooks only assert that the view did appear, or the view will disappear. There is no mention of, and really no room for, a concept of why these events might have happened. Thus, the view abstraction **requires** that much of the controller complexity be handled in the background. Complexity around whether a view should be cached, whether the system needs to reclaim memory from the controller, etc, CANNOT leak out into the realm of the developer. It's a fantastic separation of concerns, enforced by design.\n\nTo sum up, when I learned iOS, I coded for months with only the barest appreciation for what was being handled for me behind the scenes. I had no idea what the system was doing to my views and controllers when the app was backgrounded, or when the phone was rotated. And I didn't care, I put my code in the logical life cycle hook, and it just worked. On the other hand, by requiring the developer to be aware of the controller's state, Android has introduced a massive amount of incidental complexity. Eight months into the development of my first Android app, I was still encountering issues, edge cases, and crashes pertaining to lifecycle. I was still referring to documentation, and discovering new, important details about how the system worked. Overall, Android's handling of life cycle feels poorly designed, and poorly executed. In fairness to the framework engineers, Java imposes limitations, and I'm sure there are many other constraints that I'm not aware of that pushed the design in this direction. But, with iOS as an example, I would like to see reductions in the complexity of view and controller life cycle in future versions of Android.\n","code":"var Component=(()=\u003e{var c=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var u=(o,e)=\u003e()=\u003e(e||o((e={exports:{}}).exports,e),e.exports),y=(o,e)=\u003e{for(var i in e)a(o,i,{get:e[i],enumerable:!0})},s=(o,e,i,r)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let n of f(e))!w.call(o,n)\u0026\u0026n!==i\u0026\u0026a(o,n,{get:()=\u003ee[n],enumerable:!(r=p(e,n))||r.enumerable});return o};var g=(o,e,i)=\u003e(i=o!=null?c(m(o)):{},s(e||!o||!o.__esModule?a(i,\"default\",{value:o,enumerable:!0}):i,o)),v=o=\u003es(a({},\"__esModule\",{value:!0}),o);var h=u((O,l)=\u003e{l.exports=_jsx_runtime});var x={};y(x,{default:()=\u003eA,frontmatter:()=\u003eb});var t=g(h()),b={title:\"iOS \u003e Android: View Life Cycle\",date:new Date(1416756669e3),summary:\"A comparison of the view and controller life cycle hooks in iOS and Android.\",tags:[\"code\",\"android\",\"iOS\",\"mobile\"],thumbnail:\"/static/images/lifecycle/basic-lifecycle-android.png\",type:\"Blog\"};function d(o){let e=Object.assign({p:\"p\",h1:\"h1\",a:\"a\",span:\"span\",ol:\"ol\",li:\"li\",code:\"code\",div:\"div\",em:\"em\",ul:\"ul\",strong:\"strong\"},o.components),{Image:i}=e;return i||I(\"Image\",!0,\"47:1-47:75\"),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"In this post, I\\u2019m going to compare the life cycle hooks in iOS and Android, and discuss at a high level why iOS\\u2019s system is superior to Android\\u2019s. In general, iOS provides hooks that match the life cycle of the view, which creates an easy and intuitive system, and successfully hides system level concerns from the developer. On the other hand, Android's hooks follow the state of the controller, which conflates the life cycle of the view with the state of the controller, breaking the fundamental abstraction of MVC. This terrible design creates a confusing and quirky system, and exposes system level complexity to the developer.\"}),(0,t.jsxs)(e.h1,{id:\"mvc-refresher\",children:[(0,t.jsx)(e.a,{href:\"#mvc-refresher\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"MVC refresher\"]}),(0,t.jsxs)(e.p,{children:[\"To establish terminology, I'll quickly discuss \",(0,t.jsx)(e.a,{href:\"http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\",children:\"Model-View-Controller\"}),\", the design paradigm favored by both platforms. MVC seeks to reduce the complexity of user interfaces by separating concerns into models, views, and controllers. Models hold the data. Views are the representation of the data on screen, and should contain minimal logic. Controllers manage the views and their life cycle, and coordinate with models and the rest of the app. Since controllers are in the middle of everything, they are usually significantly more complicated than views.\"]}),(0,t.jsxs)(e.h1,{id:\"the-view-life-cycle\",children:[(0,t.jsx)(e.a,{href:\"#the-view-life-cycle\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"The View Life Cycle\"]}),(0,t.jsx)(e.p,{children:\"When a view is about to appear on screen, the app needs to perform the following tasks:\"}),(0,t.jsxs)(e.ol,{children:[(0,t.jsx)(e.li,{children:\"Create the view and load into memory\"}),(0,t.jsx)(e.li,{children:\"Lay out and measure the elements of the view\"}),(0,t.jsx)(e.li,{children:\"Render the view on screen\"})]}),(0,t.jsx)(e.p,{children:\"And when the view should leave the screen:\"}),(0,t.jsxs)(e.ol,{children:[(0,t.jsx)(e.li,{children:\"Hide the view\"}),(0,t.jsx)(e.li,{children:\"Release memory\"})]}),(0,t.jsx)(e.p,{children:\"These tasks represent the major stages in a view's life cycle, and a developer might want to take action at some or all of these stages. For instance, a developer may wish to persist the state of the UI when a view is going off screen. To support these actions, each platform has provided a number of hooks in their controllers.\"}),(0,t.jsxs)(e.h1,{id:\"the-life-cycle-hooks\",children:[(0,t.jsx)(e.a,{href:\"#the-life-cycle-hooks\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Life Cycle Hooks\"]}),(0,t.jsx)(e.p,{children:\"Apple's most common methods are:\"}),(0,t.jsxs)(e.ol,{children:[(0,t.jsx)(e.li,{children:\"ViewDidLoad\"}),(0,t.jsx)(e.li,{children:\"ViewWillAppear\"}),(0,t.jsx)(e.li,{children:\"ViewDidAppear\"}),(0,t.jsx)(e.li,{children:\"ViewWillDisappear\"}),(0,t.jsx)(e.li,{children:\"ViewDidDisappear\"})]}),(0,t.jsx)(e.p,{children:\"As you can see from names like 'viewDid' and 'viewWill,' the iOS hooks are focused on the state of the view. The hooks do not make any assertions about the state of the controller, or the larger state of the app. Apple has successfully separated the concerns of the view from the concerns of the rest of the app in their life cycle hooks.\"}),(0,t.jsxs)(e.p,{children:[\"This separation, along with aptly-named hooks, creates an intuitive system. For instance, it's obvious that \",(0,t.jsx)(e.code,{children:\"viewWillAppear\"}),\" will get called when the view is about to appear. It is also clear that \",(0,t.jsx)(e.code,{children:\"viewDidAppear\"}),\" will get called after the view has been rendered on screen, and after any associated system level tasks have been completed. In general, I find the iOS hooks clearly named, and thoughtfully laid out. I will note that the developer is still responsible for learning what happens at a system level before each hook. For instance, views are not measure in \",(0,t.jsx)(e.code,{children:\"viewDidLoad\"}),\", so any requests for a dimension will return 0, which can be a source of frustration for new developers. But I find these details easy to look up.\"]}),(0,t.jsx)(e.p,{children:\"Here are the equivalent Android docs.\"}),(0,t.jsx)(e.div,{children:(0,t.jsx)(i,{alt:\"Android Lifecycle\",src:\"/static/images/lifecycle/basic-lifecycle-android.png\",width:\"662\",height:\"295\"})}),(0,t.jsxs)(e.p,{children:[\"In contrast to iOS, Android's hooks get called when the \",(0,t.jsx)(e.em,{children:\"controller\"}),` is about to change state, not the view. The states, like \"paused\" and \"resumed,\" are controller states. In fact, Android's hooks make no mention of the view at all, and as we will see, only have a peripheral connection to the life cycle of the view. This abstraction is incorrect and adds enormous complexity to Android's system.`]}),(0,t.jsx)(e.p,{children:`This incorrect abstraction is apparent in the names of Android's hooks, which are confusing and ambiguous. For instance, what does it mean for a controller to be \"started,\" and how is that different than \"resumed?\" What is the distinction between \"paused\" and \"stopped?\" These state names do not convey the nuance and complexity that they encompass. Notice that the docs have parentheses explaining how these controller states match to the view life cycle, which is the more natural way to understand when these hooks will be called. Furthermore, by using the terminology \"onEvent,\" Android fails to communicate whether system level events tied to that event come before or after the hook. For instance, when a controller is paused, is the hook called immediately while the view is still on screen, or after the view has been partially occluded? This ambiguous naming increases learning time and adds cognitive overhead.`}),(0,t.jsx)(e.p,{children:\"Here's a quick comparison of the most common lifecycle methods on the two platforms, and where they fit into the life cycle of the view.\"}),(0,t.jsx)(e.div,{children:(0,t.jsx)(i,{alt:\"View Appearing\",src:\"/static/images/lifecycle/view-controller-appear.png\",width:\"960\",height:\"540\"})}),(0,t.jsx)(e.div,{children:(0,t.jsx)(i,{alt:\"View Disappearing\",src:\"/static/images/lifecycle/view-controller-disappear.png\",width:\"960\",height:\"540\"})}),(0,t.jsx)(e.p,{children:\"Side by side, the difference between iOS's view abstraction and Android's controller abstraction becomes apparent. Apple has one hook at each stage, but Android sometimes has multiple hooks, or no hooks at all. In other words, Android's controller abstraction doesn't match what a developer needs to do, making the system difficult to understand, and making it difficult to figure out where code should go.\"}),(0,t.jsxs)(e.p,{children:[\"Furthermore, by abstracting on the controller events, Android has tightly coupled the view's life cycle with the controller's life cycle, breaking the fundamental abstraction of MVC. For instance, on screen rotation, Android envisioned a scenario where a developer would want to substitute different layouts for landscape and portrait modes. This is a noble goal, and I applaud the flexibility that it grants. However, due to the controller abstraction, in order to change the view, the \",(0,t.jsx)(e.em,{children:\"controller\"}),\" also needs to change. In other words, to swap out the view and call all of the life cycle hooks again, the entire controller needs to be destroyed and recreated, along with all of its data and state. If the controller is not recreated properly, the resulting view could have bugs, lose data, or even crash, even though nothing in the controller has changed. Thus, by abstracting on the controller, Android has complected the view and the controller, which breaks the basic abstraction of MVC. It's an absolutely terrible design. As if that's not bad enough, saving and recreating a view can be heinously difficult, which I will cover in a separate blog post.\"]}),(0,t.jsx)(e.p,{children:\"Rotation is not an isolated case; Android's controller abstraction leaks controller concerns and system level complexity into the realm of the developer anywhere and everywhere. Here's a partial list of other life cycle quirks and gotchas that await the unwary Android developer.\"}),(0,t.jsxs)(e.ul,{children:[(0,t.jsx)(e.li,{children:\"Backgrounded apps brought to the foreground will often crash if state is not persisted properly.\"}),(0,t.jsx)(e.li,{children:\"The developer has to be aware that the system can destroy activities in the background.\"}),(0,t.jsx)(e.li,{children:\"onSaveInstanceState is not always called, such as when the user \\u201Cintentionally\\u201D exits the app.\"}),(0,t.jsx)(e.li,{children:\"The developer has to manually cache the state of the controller.\"}),(0,t.jsx)(e.li,{children:\"Persisted controllers can have data split between a bundle and a permanent store.\"}),(0,t.jsx)(e.li,{children:\"There are often multiple ways that a hook can be called, and the developer needs to be aware of the differences in certain situations.\"}),(0,t.jsxs)(e.li,{children:[\"There are quirks with older versions of Android, notably that \",(0,t.jsx)(e.code,{children:\"onStop\"}),\" is not guaranteed to be called in early versions of Android.\"]}),(0,t.jsx)(e.li,{children:\"Google maps objects have their own separate hell of a life cycle.\"})]}),(0,t.jsx)(e.p,{children:`Some of these points represent major failures of design, while others \"merely\" add complexity. While discussing these issues is beyond the scope of this post, if there's anything in particular you would like to read more about, drop me a comment and I'll do my best to put together a post on that subject.`}),(0,t.jsxs)(e.p,{children:[\"In contrast to Android, by tying hooks to the view, iOS has found the correct abstraction. The hooks only assert that the view did appear, or the view will disappear. There is no mention of, and really no room for, a concept of why these events might have happened. Thus, the view abstraction \",(0,t.jsx)(e.strong,{children:\"requires\"}),\" that much of the controller complexity be handled in the background. Complexity around whether a view should be cached, whether the system needs to reclaim memory from the controller, etc, CANNOT leak out into the realm of the developer. It's a fantastic separation of concerns, enforced by design.\"]}),(0,t.jsx)(e.p,{children:\"To sum up, when I learned iOS, I coded for months with only the barest appreciation for what was being handled for me behind the scenes. I had no idea what the system was doing to my views and controllers when the app was backgrounded, or when the phone was rotated. And I didn't care, I put my code in the logical life cycle hook, and it just worked. On the other hand, by requiring the developer to be aware of the controller's state, Android has introduced a massive amount of incidental complexity. Eight months into the development of my first Android app, I was still encountering issues, edge cases, and crashes pertaining to lifecycle. I was still referring to documentation, and discovering new, important details about how the system worked. Overall, Android's handling of life cycle feels poorly designed, and poorly executed. In fairness to the framework engineers, Java imposes limitations, and I'm sure there are many other constraints that I'm not aware of that pushed the design in this direction. But, with iOS as an example, I would like to see reductions in the complexity of view and controller life cycle in future versions of Android.\"})]})}function k(o={}){let{wrapper:e}=o.components||{};return e?(0,t.jsx)(e,Object.assign({},o,{children:(0,t.jsx)(d,o)})):d(o)}var A=k;function I(o,e,i){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+o+\"` to be defined: you likely forgot to import, pass, or provide it.\"+(i?\"\\nIt\\u2019s referenced in your code at `\"+i+\"` in `/home/greg/Code/Blog/_mdx_bundler_entry_point-06fbaf01-58ef-465b-8e68-f664dee51116.mdx`\":\"\"))}return v(x);})();\n;return Component;"},"_id":"blog/mobile/android-vc-lifecycle.mdx","_raw":{"sourceFilePath":"blog/mobile/android-vc-lifecycle.mdx","sourceFileName":"android-vc-lifecycle.mdx","sourceFileDir":"blog/mobile","contentType":"mdx","flattenedPath":"blog/mobile/android-vc-lifecycle"},"type":"Blog","readingTime":{"text":"8 min read","minutes":7.785,"time":467100,"words":1557},"slug":"mobile/android-vc-lifecycle","toc":[{"value":"MVC refresher","url":"#mvc-refresher","depth":1},{"value":"The View Life Cycle","url":"#the-view-life-cycle","depth":1},{"value":"The Life Cycle Hooks","url":"#the-life-cycle-hooks","depth":1}]},"authorDetails":[{"name":"Gregory Lee","avatar":"/static/images/avatar.png","occupation":"Professor of Atmospheric Science","company":"Stanford University","email":"address@yoursite.com","twitter":"https://twitter.com/Twitter","linkedin":"https://www.linkedin.com","github":"https://github.com","type":"Authors","readingTime":{"text":"1 min read","minutes":0.015,"time":900,"words":3},"slug":"default","toc":[]}],"prev":{"title":"Layouts Part III: The Beauty of Layout Weight and Conclusion","date":"2014-11-17T01:05:23.000Z","summary":"A discussion of Android's layout weight and the fantastic abstraction it represents.  There is no equivalent on iOS.","tags":["code","mobile","android"],"thumbnail":"/linear-layout/android-buttons-weight.png","series":{"name":"Android Layouts","number":3,"type":"Series","_raw":{}},"type":"Blog","readingTime":{"text":"4 min read","minutes":3.61,"time":216600,"words":722},"slug":"mobile/android-layouts-3","toc":[]},"next":{"title":"El Capitan Climbers","date":"2015-01-28T16:47:06.000Z","tags":["photography"],"thumbnail":"/static/images/photography/el-cap.jpg","image":"/static/images/photography/el-cap.jpg","authors":["gregliest"],"type":"Blog","readingTime":{"text":"1 min read","minutes":0.245,"time":14700,"words":49},"slug":"photography/el-capitan-climbers","toc":[{"value":"El Capitan Climbers, Yosemite, USA","url":"#el-capitan-climbers-yosemite-usa","depth":1}]}},"__N_SSG":true},"page":"/blog/[...slug]","query":{"slug":["mobile","android-vc-lifecycle"]},"buildId":"Uk5C59Zgl51sx5Hq37kK4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>