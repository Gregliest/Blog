{
  "pageProps": {
    "post": {
      "title": "Layouts Part III: The Beauty of Layout Weight and Conclusion",
      "date": "2014-11-17T01:05:23.000Z",
      "summary": "A discussion of Android's layout weight and the fantastic abstraction it represents.  There is no equivalent on iOS.",
      "tags": ["code", "mobile", "android"],
      "thumbnail": "/linear-layout/android-buttons-weight.png",
      "series": { "name": "Android Layouts", "number": 3, "type": "Series", "_raw": {} },
      "body": {
        "raw": "\nAndroid's power doesn't stop at just add/remove/collapse. Letâ€™s take the view from the previous post one step further by replacing the single button with a row of three equally sized buttons. In Android, I can embed three buttons in a horizontal LinearLayout. Android provides a convenient attribute, `layout_weight` that dictates how elements of a layout expand to fill empty space. The weight of the current view divided by the total weights in the layout equal the percent of the layout that the view will take up. To get all of the buttons to be the same width, taking up the whole width of the screen, I simply set all of the layout_weights to be equal, and the `layout_width` of each button to be \"0dp,\" like so.\n\n```css\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                  android:orientation=\"horizontal\"\n                  android:layout_width=\"fill_parent\"\n                  android:layout_height=\"wrap_content\">\n        <Button\n                android:layout_width=\"0dp\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Button 1\"\n                android:layout_weight=\"1\"/>\n        <Button\n                android:layout_width=\"0dp\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Button 2\"\n                android:layout_weight=\"1\"/>\n        <Button\n                android:layout_width=\"0dp\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Button 3\"\n                android:layout_weight=\"1\"/>\n    </LinearLayout>\n```\n\nNow let's say I only want the three buttons to take up part of the screen. In Android, I simply resize the LinearLayout, and everything else happens for free. On a whim, I've also centered the whole button layout with the `layout_gravity` attribute. It's that easy.\n\n```css\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                  android:orientation=\"horizontal\"\n                  android:layout_gravity=\"center_horizontal\"\n                  android:layout_width=\"200dp\"\n                  android:layout_height=\"wrap_content\">\n```\n\n![Buttons](/static/images/linear-layout/android-buttons.png)\n\n![Buttons Center](/static/images/linear-layout/android-buttons-center.png)\n\n_Android button layout, before and after resizing_\n\nLet's say I want the middle button to be twice as big as the other two buttons. Simply change the weight of the middle button to 2 instead of 1. It's a one character change.\n\n```css\n        <Button\n                android:layout_width=\"0dp\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Button 2\"\n                android:layout_weight=\"2\"/>\n```\n\n![Buttons Weight](/static/images/linear-layout/android-buttons-weight.png)\n\nLet's say I want to move these buttons to reside above the picture. Because all of the information for this layout is contained inside the LinearLayout xml tag, I can simply cut/paste the whole LinearLayout. Likewise, I can cut/paste to move the layout to another view entirely. As you can see, this abstraction allows for an incredible amount of flexibility, and is extremely powerful. It successfully hides much of the complexity around layouts, allowing a developer to focus on building beautiful views. And, for all the cases that Linear Layouts can't handle, Android provides two other awesome layout classes, RelativeLayout and FrameLayout. I'll discuss them in a future blog post.\n\nIt's a different story in iOS. A button layout with the type of flexibility I demonstrated on Android is difficult or impossible to reproduce. There are ways to hard code, or semi-hard code the layout, but the result will not be flexible or robust against certain design changes. It's enough of a pain to try to recreate on iOS that I'm going to leave it to a future blog post, if there's enough interest. Or if someone has a brilliant, simple way, I'm all ears.\n\nTo summarize, the fundamental mistake in iOS is a lack of a coherent abstraction. Constraints are very low level building blocks for views, and they often do not represent the fundamental tasks that a developer is trying to accomplish. So, the developer has to spend a lot of time and energy translating desires like, \"I want a couple of buttons on screen that expand on rotation,\" into this language of constraints. It's time consuming, brainpower intensive, and is a distraction from the business logic of the app. Also, the developer usually has to choose between multiple ways of accomplishing their task, none of them simple. Thus, different code bases will often handle views differently, and even different developers in the same codebase will use different paradigms. This inconsistency leads to complicated, asymmetric view hierarchies.\n\nOn the other hand, by providing layout abstractions, Android has managed to hide much of the complexity surrounding views. Developers can focus on making the important decisions like how a view should behave on rotation and how elements should resize on larger screens. Also, by providing readable xml, Android has successfully encapsulated the relevant attributes of each view element, which keeps the code organized and helps developers design views that can be easily moved, reused, and even subclassed. When I'm building an iOS app, I usually plan to spend the bulk of my time on layout. In Android, layouts are often less than 25% of my time. So, in the future, with Android as an example, I would like to see Apple introduce layout abstractions to reduce complexity in iOS app views.\n",
        "code": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),N=(a,e)=>{for(var t in e)o(a,t,{get:e[t],enumerable:!0})},l=(a,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of u(e))!y.call(a,s)&&s!==t&&o(a,s,{get:()=>e[s],enumerable:!(i=p(e,s))||i.enumerable});return a};var k=(a,e,t)=>(t=a!=null?h(m(a)):{},l(e||!a||!a.__esModule?o(t,\"default\",{value:a,enumerable:!0}):t,a)),f=a=>l(o({},\"__esModule\",{value:!0}),a);var c=g((L,r)=>{r.exports=_jsx_runtime});var I={};N(I,{default:()=>v,frontmatter:()=>w});var n=k(c()),w={title:\"Layouts Part III: The Beauty of Layout Weight and Conclusion\",date:new Date(1416186323e3),summary:\"A discussion of Android's layout weight and the fantastic abstraction it represents.  There is no equivalent on iOS.\",tags:[\"code\",\"mobile\",\"android\"],thumbnail:\"/linear-layout/android-buttons-weight.png\",series:{name:\"Android Layouts\",number:3},type:\"Blog\"};function d(a){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",span:\"span\",div:\"div\",em:\"em\"},a.components),{Image:t}=e;return t||_(\"Image\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Android's power doesn't stop at just add/remove/collapse. Let\\u2019s take the view from the previous post one step further by replacing the single button with a row of three equally sized buttons. In Android, I can embed three buttons in a horizontal LinearLayout. Android provides a convenient attribute, \",(0,n.jsx)(e.code,{children:\"layout_weight\"}),\" that dictates how elements of a layout expand to fill empty space. The weight of the current view divided by the total weights in the layout equal the percent of the layout that the view will take up. To get all of the buttons to be the same width, taking up the whole width of the screen, I simply set all of the layout_weights to be equal, and the \",(0,n.jsx)(e.code,{children:\"layout_width\"}),' of each button to be \"0dp,\" like so.']}),(0,n.jsx)(e.pre,{className:\"language-css\",children:(0,n.jsxs)(e.code,{className:\"language-css code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"<LinearLayout \",(0,n.jsx)(e.span,{className:\"token property\",children:\"xmlns\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"android=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"http://schemas.android.com/apk/res/android\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"orientation=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"horizontal\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_width=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"fill_parent\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_height=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"wrap_content\"'}),`>\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        <Button\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_width=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"0dp\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_height=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"wrap_content\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"text=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"Button 1\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_weight=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"1\"'}),`/>\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        <Button\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_width=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"0dp\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_height=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"wrap_content\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"text=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"Button 2\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_weight=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"1\"'}),`/>\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        <Button\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_width=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"0dp\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_height=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"wrap_content\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"text=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"Button 3\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_weight=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"1\"'}),`/>\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    </LinearLayout>\n`})]})}),(0,n.jsxs)(e.p,{children:[\"Now let's say I only want the three buttons to take up part of the screen. In Android, I simply resize the LinearLayout, and everything else happens for free. On a whim, I've also centered the whole button layout with the \",(0,n.jsx)(e.code,{children:\"layout_gravity\"}),\" attribute. It's that easy.\"]}),(0,n.jsx)(e.pre,{className:\"language-css\",children:(0,n.jsxs)(e.code,{className:\"language-css code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"<LinearLayout \",(0,n.jsx)(e.span,{className:\"token property\",children:\"xmlns\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"android=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"http://schemas.android.com/apk/res/android\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"orientation=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"horizontal\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_gravity=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"center_horizontal\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_width=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"200dp\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                  \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_height=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"wrap_content\"'}),`>\n`]})]})}),(0,n.jsx)(e.div,{children:(0,n.jsx)(t,{alt:\"Buttons\",src:\"/static/images/linear-layout/android-buttons.png\",width:\"500\",height:\"828\"})}),(0,n.jsx)(e.div,{children:(0,n.jsx)(t,{alt:\"Buttons Center\",src:\"/static/images/linear-layout/android-buttons-center.png\",width:\"482\",height:\"825\"})}),(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Android button layout, before and after resizing\"})}),(0,n.jsx)(e.p,{children:\"Let's say I want the middle button to be twice as big as the other two buttons. Simply change the weight of the middle button to 2 instead of 1. It's a one character change.\"}),(0,n.jsx)(e.pre,{className:\"language-css\",children:(0,n.jsxs)(e.code,{className:\"language-css code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`        <Button\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_width=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"0dp\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_height=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"wrap_content\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"text=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"Button 2\"'}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"                \",(0,n.jsx)(e.span,{className:\"token property\",children:\"android\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\":\"}),\"layout_weight=\",(0,n.jsx)(e.span,{className:\"token string\",children:'\"2\"'}),`/>\n`]})]})}),(0,n.jsx)(e.div,{children:(0,n.jsx)(t,{alt:\"Buttons Weight\",src:\"/static/images/linear-layout/android-buttons-weight.png\",width:\"484\",height:\"828\"})}),(0,n.jsx)(e.p,{children:\"Let's say I want to move these buttons to reside above the picture. Because all of the information for this layout is contained inside the LinearLayout xml tag, I can simply cut/paste the whole LinearLayout. Likewise, I can cut/paste to move the layout to another view entirely. As you can see, this abstraction allows for an incredible amount of flexibility, and is extremely powerful. It successfully hides much of the complexity around layouts, allowing a developer to focus on building beautiful views. And, for all the cases that Linear Layouts can't handle, Android provides two other awesome layout classes, RelativeLayout and FrameLayout. I'll discuss them in a future blog post.\"}),(0,n.jsx)(e.p,{children:\"It's a different story in iOS. A button layout with the type of flexibility I demonstrated on Android is difficult or impossible to reproduce. There are ways to hard code, or semi-hard code the layout, but the result will not be flexible or robust against certain design changes. It's enough of a pain to try to recreate on iOS that I'm going to leave it to a future blog post, if there's enough interest. Or if someone has a brilliant, simple way, I'm all ears.\"}),(0,n.jsx)(e.p,{children:`To summarize, the fundamental mistake in iOS is a lack of a coherent abstraction. Constraints are very low level building blocks for views, and they often do not represent the fundamental tasks that a developer is trying to accomplish. So, the developer has to spend a lot of time and energy translating desires like, \"I want a couple of buttons on screen that expand on rotation,\" into this language of constraints. It's time consuming, brainpower intensive, and is a distraction from the business logic of the app. Also, the developer usually has to choose between multiple ways of accomplishing their task, none of them simple. Thus, different code bases will often handle views differently, and even different developers in the same codebase will use different paradigms. This inconsistency leads to complicated, asymmetric view hierarchies.`}),(0,n.jsx)(e.p,{children:\"On the other hand, by providing layout abstractions, Android has managed to hide much of the complexity surrounding views. Developers can focus on making the important decisions like how a view should behave on rotation and how elements should resize on larger screens. Also, by providing readable xml, Android has successfully encapsulated the relevant attributes of each view element, which keeps the code organized and helps developers design views that can be easily moved, reused, and even subclassed. When I'm building an iOS app, I usually plan to spend the bulk of my time on layout. In Android, layouts are often less than 25% of my time. So, in the future, with Android as an example, I would like to see Apple introduce layout abstractions to reduce complexity in iOS app views.\"})]})}function b(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var v=b;function _(a,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+a+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return f(I);})();\n;return Component;"
      },
      "_id": "blog/mobile/android-layouts-3.mdx",
      "_raw": {
        "sourceFilePath": "blog/mobile/android-layouts-3.mdx",
        "sourceFileName": "android-layouts-3.mdx",
        "sourceFileDir": "blog/mobile",
        "contentType": "mdx",
        "flattenedPath": "blog/mobile/android-layouts-3"
      },
      "type": "Blog",
      "readingTime": { "text": "4 min read", "minutes": 3.61, "time": 216600, "words": 722 },
      "slug": "mobile/android-layouts-3",
      "toc": []
    },
    "authorDetails": [
      {
        "name": "Gregory Lee",
        "avatar": "/static/images/avatar.png",
        "occupation": "Professor of Atmospheric Science",
        "company": "Stanford University",
        "email": "address@yoursite.com",
        "twitter": "https://twitter.com/Twitter",
        "linkedin": "https://www.linkedin.com",
        "github": "https://github.com",
        "type": "Authors",
        "readingTime": { "text": "1 min read", "minutes": 0.015, "time": 900, "words": 3 },
        "slug": "default",
        "toc": []
      }
    ],
    "prev": {
      "title": "Layouts Part II: Add/Remove/Collapse",
      "date": "2014-11-16T01:04:45.000Z",
      "summary": "A comparison of the ease of adding, removing, and collapsing views in an Android Linear Layout vs. an iOS Interface Builder view.",
      "tags": ["code", "android", "iOS", "mobile"],
      "thumbnail": "/linear-layout/android-visible.png",
      "series": { "name": "Android Layouts", "number": 2, "type": "Series", "_raw": {} },
      "type": "Blog",
      "readingTime": { "text": "6 min read", "minutes": 5.525, "time": 331500, "words": 1105 },
      "slug": "mobile/android-layouts-2",
      "toc": [{ "value": "Visibility", "url": "#visibility", "depth": 1 }]
    },
    "next": {
      "title": "iOS > Android: View Life Cycle",
      "date": "2014-11-23T15:31:09.000Z",
      "summary": "A comparison of the view and controller life cycle hooks in iOS and Android.",
      "tags": ["code", "android", "iOS", "mobile"],
      "thumbnail": "/static/images/lifecycle/basic-lifecycle-android.png",
      "type": "Blog",
      "readingTime": { "text": "8 min read", "minutes": 7.785, "time": 467100, "words": 1557 },
      "slug": "mobile/android-vc-lifecycle",
      "toc": [
        { "value": "MVC refresher", "url": "#mvc-refresher", "depth": 1 },
        { "value": "The View Life Cycle", "url": "#the-view-life-cycle", "depth": 1 },
        { "value": "The Life Cycle Hooks", "url": "#the-life-cycle-hooks", "depth": 1 }
      ]
    }
  },
  "__N_SSG": true
}
